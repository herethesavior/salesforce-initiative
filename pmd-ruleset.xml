<?xml version="1.0" encoding="UTF-8" ?>
<!-- @name: Sustainability Rules
     @description: Custom ruleset focused on performance and sustainability
     @author: Ryan Joshua Dela Cruz -->
<ruleset
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    name="Sustainability Rules"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd"
>
    <description>Custom ruleset focused on performance and sustainability</description>

    <!-- @name: AvoidDebugStatements
         @description:Debug statements contribute to longer transactions and consume Apex 
         CPU time even when debug logs are not being captured. When possible make use of 
         other debugging techniques such as the Apex Replay Debugger and Checkpoints that 
         could cover most use cases. -->
    <rule
        name="AvoidDebugStatements"
        ref="category/apex/performance.xml/AvoidDebugStatements"
        language="apex"
        message="Avoid leaving System.debug() statements in code as they negatively influence performance."
        class="net.sourceforge.pmd.lang.apex.rule.ApexXPathRule"
    >
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
                    //MethodCallExpression[lower-case(@FullMethodName)='system.debug']
                    ]]>
                </value>
            </property>
        </properties>
    </rule>

    <!-- @name: OperationWithLimitsInLoop
         @description: Database class methods, DML operations, SOQL queries, SOSL queries, 
         Approval class methods, Email sending, async scheduling or queueing within loops  
         can cause governor limit exceptions. Instead, try to batch up the data into a 
         list and invoke the operation once on that list of data outside the loop. -->
    <rule
        name="OperationWithLimitsInLoop"
        ref="category/apex/performance.xml/OperationWithLimitsInLoop"
        message="Avoid operations in loops that may hit governor limits"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: EagerlyLoadedDescribeSObjectResult
         @description: This rule finds DescribeSObjectResults which could have been 
         loaded eagerly via SObjectType.getDescribe().
        
         When using SObjectType.getDescribe() or Schema.describeSObjects() without 
         supplying a SObjectDescribeOptions, implicitly it will be using 
         SObjectDescribeOptions.DEFAULT and then all child relationships will be 
         loaded eagerly regardless whether this information is needed or not.
        
         This has a potential negative performance impact. Instead 
         SObjectType.getDescribe(options) or Schema.describeSObjects(SObjectTypes, options) 
         should be used and a SObjectDescribeOptions should be supplied. By using 
         SObjectDescribeOptions.DEFERRED the describe attributes will be lazily 
         initialized at first use.-->
    <rule
        name="EagerlyLoadedDescribeSObjectResult"
        ref="category/apex/performance.xml/EagerlyLoadedDescribeSObjectResult"
        message="Do not allow SObjectDescribeOptions.DEFAULT option to ensure consistent results no matter where getDescribe is called"
    >
        <priority>1</priority>
        <properties>
            <property name="noDefault" value="false" />
        </properties>
    </rule>

    <!-- @name: AvoidDirectAccessTriggerMaps
         @description: Avoid directly accessing Trigger.old and Trigger.new as it can 
         lead to a bug. Triggers should be bulkified and iterate through the map to
         handle the actions for each item separately. -->
    <rule
        name="AvoidDirectAccessTriggerMap"
        ref="category/apex/errorprone.xml/AvoidDirectAccessTriggerMap"
        message="Avoid directly accessing Trigger.old and Trigger.new"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: AvoidLogicInTrigger
         @description: As triggers do not allow methods like regular classes they are 
         less flexibleand suited to apply good encapsulation style. Therefore delegate 
         the triggers work to a regular class (often called Trigger handler class).

        See more here: https://developer.salesforce.com/page/Trigger_Frameworks_and_Apex_Trigger_Best_Practices -->
    <rule
        name="AvoidLogicInTrigger"
        ref="category/apex/bestpractices.xml/AvoidLogicInTrigger"
        message="Avoid logic in triggers, delegate the triggers work to a regular class (often called Trigger handler class"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: CyclomaticComplexity
         @description: The complexity of methods directly affects maintenance costs  
         and readability. Concentrating too much decisional logic in a single method 
         makes its behaviour hard to read and change.
        
         Cyclomatic complexity assesses the complexity of a method by counting the 
         number of decision points in a method, plus one for the method entry. 
         Decision points are places where the control flow jumps to another place 
         in the program. As such, they include all control flow statements, 
         such as ‘if’, ‘while’, ‘for’, and ‘case’.

         Generally, numbers ranging from 1-4 denote low complexity, 
         5-7 denote moderate complexity, 8-10 denote high complexity, 
         and 11+ is very high complexity. 
         
         Additionally, classes with many methods of moderate complexity get
         reported as well once the total of their methods’ complexities reaches 40, 
         even if none of the methods was directly reported. -->
    <rule
        name="CyclomaticComplexity"
        ref="category/apex/design.xml/CyclomaticComplexity"
        message="Logic should be broken down into several smaller methods or subcomponents"
    >
        <priority>1</priority>
        <properties>
            <property name="classReportLevel" value="40" />
            <property name="methodReportLevel" value="10" />
        </properties>
    </rule>

    <!-- @name: CognitiveComplexity
         @description: Methods that are highly complex are difficult to read and more
         costly to maintain. If you include too much decisional logic within a single
         method, you make its behavior hard to understand and more difficult to modify.

         Cognitive complexity is a measure of how difficult it is for humans to read and 
         understand a method. Code that contains a break in the control flow is more 
         complex, whereas the use of language shorthands doesn’t increase the level of 
         complexity. Nested control flows can make a method more difficult to understand, 
         with each additional nesting of the control flow leading to an increase in 
         cognitive complexity.
    
         Information about Cognitive complexity can be found in the original paper here: 
         https://www.sonarsource.com/docs/CognitiveComplexity.pdf -->
    <rule
        name="CognitiveComplexity"
        ref="category/apex/design.xml/CognitiveComplexity"
        message="Avoid structuring complex methods and classes. They are hard to read and costly to maintain."
    >
        <priority>1</priority>
        <properties>
            <property name="classReportLevel" value="50" />
            <property name="methodReportLevel" value="15" />
        </properties>
    </rule>

    <!-- @name: AvoidDeeplyNestedIfStmts
         @description: Avoid creating deeply nested if-then statements since they are 
         harder to read and error-prone to maintain. -->
    <rule
        name="AvoidDeeplyNestedIfStmts"
        ref="category/apex/design.xml/AvoidDeeplyNestedIfStmts"
        message="Deeply nested if..else statements are hard to read and error-prone to maintain"
    >
        <priority>1</priority>
        <properties>
            <property name="problemDepth" value="3" />
        </properties>
    </rule>

    <!-- @name: UnusedLocalVariable  
         @description: Detects when a local variable is declared and/or assigned but 
         not used. Unused local variables are most likely leftovers due to incomplete 
         transforming of the code. Such variables take up space and gives no value
         so they must be removed. -->
    <rule name="UnusedLocalVariable" ref="category/apex/bestpractices.xml/UnusedLocalVariable">
        <priority>1</priority>
    </rule>

    <!-- @name: ApexCSRF
         @description: Having DML operations in Apex class constructor or initializers 
         can have unexpected side effects: By just accessing a page, the DML statements 
         would be executed and the database would be modified. Just querying the database 
         is permitted.

         In addition to constructors and initializers, any method called init is checked 
         as well. Salesforce Apex already protects against this scenario and raises a 
         runtime exception. -->
    <rule name="ApexCSRF" ref="category/apex/errorprone.xml/ApexCSRF">
        <priority>1</priority>
    </rule>

    <!-- @name: EmptyCatchBlock
         @description: Empty Catch Block finds instances where an exception is caught, 
         but nothing is done. In most circumstances, this swallows an exception which 
         should either be acted on or reported. -->
    <rule name="EmptyCatchBlock" ref="category/apex/errorprone.xml/EmptyCatchBlock" message="Avoid empty catch blocks">
        <priority>1</priority>
        <properties>
            <property name="allowCommentedBlocks" value="false" />
            <property name="allowExceptionNameRegex" value="^(ignored|expected)$" />
        </properties>
    </rule>

    <!-- @name: EmptyIfStmt
         @description: Empty If Statement finds instances where a condition is checked 
         but nothing is done about it. -->
    <rule name="EmptyIfStmt" ref="category/apex/errorprone.xml/EmptyIfStmt" message="Avoid empty 'if' statements">
        <priority>1</priority>
    </rule>

    <!-- @name: EmptyWhileStmt
         @description: Empty While Statement finds all instances where a while statement 
         does nothing. If it is a timing loop, then you should use Thread.sleep() for it; 
         if it is a while loop that does a lot in the exit expression, rewrite it to 
         make it clearer. -->
    <rule
        name="EmptyWhileStmt"
        ref="category/apex/errorprone.xml/EmptyWhileStmt"
        message="Avoid empty 'while' statements"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: EmptyTryOrFinallyBlock
         @description: Avoid empty try or finally blocks - what’s the point? -->
    <rule
        name="EmptyTryOrFinallyBlock"
        ref="category/apex/errorprone.xml/EmptyTryOrFinallyBlock"
        message="Avoid empty 'try' or 'finally' blocks"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: EmptyStatementBlock
         @description: Empty block statements serve no purpose and should be removed. -->
    <rule
        name="EmptyStatementBlock"
        ref="category/apex/errorprone.xml/EmptyStatementBlock"
        message="Avoid empty block statements."
    >
        <priority>1</priority>
    </rule>

    <!-- @name: AvoidNonExistentAnnotations
         @description: Apex supported non existent annotations for legacy reasons. In 
         the future, use of such non-existent annotations could result in broken apex 
         code that will not compile. This will prevent users of garbage annotations from 
         being able to use legitimate annotations added to Apex in the future.
         A full list of supported annotations can be found at 
         https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_annotation.htm -->
    <rule name="AvoidNonExistentAnnotations" ref="category/apex/errorprone.xml/AvoidNonExistentAnnotations">
        <priority>1</priority>
    </rule>

    <!-- @name: MethodWithSameNameAsEnclosingClass
         @description: Non-constructor methods should not have the same name as the 
         enclosing class. -->
    <rule
        name="MethodWithSameNameAsEnclosingClass"
        ref="category/apex/errorprone.xml/MethodWithSameNameAsEnclosingClass"
    >
        <priority>1</priority>
    </rule>

    <!-- @name: AvoidHardcodingId
         @description: When deploying Apex code between sandbox and production 
         environments, or installing Force.com AppExchange packages, it is 
         essential to avoid hardcoding IDs in the Apex code. By doing so, 
         if the record IDs change between environments, the logic can 
         dynamically identify the proper data to operate against and not fail. -->
    <rule name="AvoidHardcodingId" ref="category/apex/errorprone.xml/AvoidHardcodingId" message="Avoid hardcoding ID's">
        <priority>1</priority>
    </rule>

    <!-- @name: InaccessibleAuraEnabledGetter
         @description: In the Summer ‘21 release, a mandatory security update 
         enforces access modifiers on Apex properties in Lightning component 
         markup. The update prevents access to private or protected Apex getters 
         from Aura and Lightning Web Components -->
    <rule name="InaccessibleAuraEnabledGetter" ref="category/apex/errorprone.xml/InaccessibleAuraEnabledGetter">
        <priority>1</priority>
    </rule>

    <!-- @name: AvoidGlobalModifier
         @description: Global classes should be avoided (especially in managed 
         packages) as they can never be deleted or changed in signature. 
         Always check twice if something needs to be global. Many interfaces 
         (e.g. Batch) required global modifiers in the past but don’t require 
         this anymore. Don’t lock yourself in. -->
    <rule name="AvoidGlobalModifier" ref="category/apex/bestpractices.xml/AvoidGlobalModifier">
        <priority>1</priority>
    </rule>

    <!-- @name: OverrideBothEqualsAndHashcode
         @description: Override both public Boolean equals(Object obj), and 
         public Integer hashCode(), or override neither. Even if you are 
         inheriting a hashCode() from a parent class, consider implementing 
         hashCode and explicitly delegating to your superclass

         This is especially important when Using Custom Types in Map Keys and Sets - 
         https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/langCon_apex_collections_maps_keys_userdefined.htm -->
    <rule name="OverrideBothEqualsAndHashcode" ref="category/apex/errorprone.xml/OverrideBothEqualsAndHashcode">
        <priority>2</priority>
    </rule>

    <!-- @name: ApexDangerousMethods
         @description: Checks against calling dangerous methods.

         For the time being, it reports:
         * Against FinancialForce’s Configuration.disableTriggerCRUDSecurity(). 
         Disabling CRUD security opens the door to several attacks and requires 
         manual validation, which is unreliable.
         * Calling System.debug passing sensitive data as parameter, which could 
         lead to exposure of private data. -->
    <rule
        name="ApexDangerousMethods"
        ref="category/apex/security.xml/ApexDangerousMethods"
        message="Avoid calling potentially dangerous method"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ExcessiveClassLength
         @description: Excessive class file lengths are usually indications that 
         the class may be burdened with excessive responsibilities that could be 
         provided by external classes or functions. In breaking these methods 
         apart the code becomes more manageable and riper for reuse. -->
    <rule
        name="ExcessiveClassLength"
        ref="category/apex/design.xml/ExcessiveClassLength"
        message="Avoid really long classes (lines of code)"
    >
        <priority>2</priority>
        <properties>
            <property name="minimum" value="1000" />
        </properties>
    </rule>

    <!-- @name: ExcessiveParameterList
         @description: Methods with numerous parameters are a challenge to maintain, 
         especially if most of them share the same datatype. These situations usually 
         denote the need for new objects to wrap the numerous parameters. -->
    <rule
        name="ExcessiveParameterList"
        ref="category/apex/design.xml/ExcessiveParameterList"
        message="Instead of multiple parameters, consider wrapping param to objects"
    >
        <priority>2</priority>
        <properties>
            <property name="minimum" value="4" />
        </properties>
    </rule>

    <!-- @name: ExcessivePublicCount
         @description: Classes with large numbers of public methods and attributes 
         require disproportionate testing efforts since combinational side effects 
         grow rapidly and increase risk. Refactoring these classes into smaller ones 
         not only increases testability and reliability but also allows new variations 
         to be developed easily. -->
    <rule
        ref="category/apex/design.xml/ExcessivePublicCount"
        message="This class has too many public methods and attributes"
    >
        <priority>2</priority>
        <properties>
            <property name="minimum" value="20" />
        </properties>
    </rule>

    <!-- @name: NcssConstructorCount
         @description: This rule uses the NCSS (Non-Commenting Source Statements) algorithm 
         to determine the amount of source code that actually does stuff for a given constructor. 
         NCSS ignores comments, and counts actual statements. Using this algorithm, lines of 
         code that are split are counted as one. -->
    <rule
        name="NcssConstructorCount"
        ref="category/apex/design.xml/NcssConstructorCount"
        message="The constructor has an NCSS line count of {0}"
    >
        <priority>3</priority>
        <properties>
            <property name="minimum" value="20" />
        </properties>
    </rule>

    <!-- @name: NcssMethodCount
         @description: This rule uses the NCSS (Non-Commenting Source Statements) algorithm 
         to determine the amount of source code that actually does stuff for a given method. 
         NCSS ignores comments, and counts actual statements. Using this algorithm, lines of 
         code that are split are counted as one. -->
    <rule
        name="NcssMethodCount"
        ref="category/apex/design.xml/NcssMethodCount"
        message="The method {0}() has an NCSS line count of {1}"
    >
        <priority>3</priority>
        <properties>
            <property name="minimum" value="40" />
        </properties>
    </rule>

    <!-- @name: NcssTypeCount
         @description: This rule uses the NCSS (Non-Commenting Source Statements) algorithm 
         to determine the amount of source code that actually does stuff for a given type. 
         NCSS ignores comments, and counts actual statements. Using this algorithm, lines 
         of code that are split are counted as one. -->
    <rule
        name="NcssTypeCount"
        ref="category/apex/design.xml/NcssTypeCount"
        message="The type has an NCSS line count of {0}"
    >
        <priority>3</priority>
        <properties>
            <property name="minimum" value="500" />
        </properties>
    </rule>

    <!-- @name: TooManyFields
         @description: Classes that have too many fields can become unwieldy and could be 
         redesigned to have fewer fields, possibly through grouping related fields in new 
         objects. For example, a class with individual city/state/zip fields could park 
         them within a single Address field. -->
    <rule
        name="TooManyFields"
        ref="category/apex/design.xml/TooManyFields"
        message="Avoid classes with too many fields"
    >
        <priority>2</priority>
        <properties>
            <property name="maxfields" value="15" />
        </properties>
    </rule>

    <!-- @name: ApexSharingViolations
         @description: Detect classes declared without explicit sharing mode if DML
         methods are used. This forces the developer to take access restrictions into 
         account before modifying objects. -->
    <rule
        name="ApexSharingViolations"
        ref="category/apex/security.xml/ApexSharingViolations"
        message="Apex classes should declare a sharing model if DML or SOQL is used"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexInsecureEndpoint
         @description: Checks against accessing endpoints under plain http. You should 
         always use https for security. -->
    <rule
        name="ApexInsecureEndpoint"
        ref="category/apex/security.xml/ApexInsecureEndpoint"
        message="Apex callouts should use encrypted communication channels"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexOpenRedirect 
         @description: Checks against redirects to user-controlled locations. This 
         prevents attackers from redirecting users to phishing sites. -->
    <rule
        name="ApexOpenRedirect"
        ref="category/apex/security.xml/ApexOpenRedirect"
        message="Apex classes should safely redirect to a known location"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexSOQLInjection
         @description: Detects the usage of untrusted / unescaped variables 
         in DML queries. -->
    <rule
        name="ApexSOQLInjection"
        ref="category/apex/security.xml/ApexSOQLInjection"
        message="Apex classes should escape variables merged in DML query"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexXSSFromURLParam
         @description: Makes sure that all values obtained from URL parameters 
         are properly escaped / sanitized to avoid XSS attacks. -->
    <rule
        name="ApexXSSFromURLParam"
        ref="category/apex/security.xml/ApexXSSFromURLParam"
        message="Apex classes should escape Strings obtained from URL parameters"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexXSSFromEscapeFalse
         @description: Reports on calls to addError with disabled escaping. The 
         message passed to addError will be displayed directly to the user in the 
         UI, making it prime ground for XSS attacks if unescaped. -->
    <rule name="ApexXSSFromEscapeFalse" ref="category/apex/security.xml/ApexXSSFromEscapeFalse">
        <priority>2</priority>
    </rule>

    <!-- @name: ApexBadCrypto
         @description: The rule makes sure you are using randomly generated IVs 
         and keys for Crypto calls. Hard-wiring these values greatly compromises 
         the security of encrypted data. -->
    <rule
        name="ApexBadCrypto"
        ref="category/apex/security.xml/ApexBadCrypto"
        message="Apex Crypto should use random IV/key"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexCRUDViolation
         @description: The rule validates you are checking for access permissions 
         before a SOQL/SOSL/DML operation. Since Apex runs in system mode not 
         having proper permissions checks results in escalation of privilege and 
         may produce runtime errors. This check forces you to handle such scenarios. -->
    <rule
        name="ApexCRUDViolation"
        ref="category/apex/security.xml/ApexCRUDViolation"
        message="Validate CRUD permission before SOQL/DML operation"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ApexSuggestUsingNamedCred
         @description: Detects hardcoded credentials used in requests to an endpoint.
         You should refrain from hardcoding credentials:

         * They are hard to mantain by being mixed in application code
         * Particularly hard to update them when used from different classes
         * Granting a developer access to the codebase means granting knowledge 
           of credentials, keeping a two-level access is not possible.
         * Using different credentials for different environments is troublesome and error-prone.

         Instead, you should use Named Credentials and a callout endpoint.
         For more information, you can check 
         https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_callouts_named_credentials.htm -->
    <rule
        name="ApexSuggestUsingNamedCred"
        ref="category/apex/security.xml/ApexSuggestUsingNamedCred"
        message="Consider using named credentials for authenticated callouts"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ClassNamingConventions
         @description: Configurable naming conventions for type declarations. 
         This rule reports type declarations which do not match the regex that 
         applies to their specific kind (e.g. enum or interface). Each regex 
         can be configured through properties.

         By default this rule uses the standard Apex naming convention (Pascal case). -->
    <rule name="ClassNamingConventions" ref="category/apex/codestyle.xml/ClassNamingConventions">
        <priority>3</priority>
        <properties>
            <property name="testClassPattern" value="[A-Z][a-zA-Z0-9_]*" />
            <property name="abstractClassPattern" value="[A-Z][a-zA-Z0-9_]*" />
            <property name="classPattern" value="[A-Z][a-zA-Z0-9_]*" />
            <property name="interfacePattern" value="[A-Z][a-zA-Z0-9_]*" />
            <property name="enumPattern" value="[A-Z][a-zA-Z0-9_]*" />
        </properties>
    </rule>

    <!-- @name: FieldNamingConventions
         @description: Configurable naming conventions for field declarations. This 
         rule reports variable declarations which do not match the regex that applies 
         to their specific kind —e.g. constants (static final), static field, final 
         field. Each regex can be configured through properties.

         By default this rule uses the standard Apex naming convention (Camel case). -->
    <rule name="FieldNamingConventions" ref="category/apex/codestyle.xml/FieldNamingConventions">
        <priority>1</priority>
        <properties>
            <property name="enumConstantPattern" value="[A-Z][A-Z0-9_]*" />
            <property name="constantPattern" value="[A-Z][A-Z0-9_]*" />
            <property name="finalPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="staticPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="instancePattern" value="[a-z][a-zA-Z0-9]*" />
        </properties>
    </rule>

    <!-- @name: FormalParameterNamingConventions
         @description: Configurable naming conventions for formal parameters of methods. 
         This rule reports formal parameters which do not match the regex that applies 
         to their specific kind (e.g. method parameter, or final method parameter). 
         Each regex can be configured through properties.

         By default this rule uses the standard Apex naming convention (Camel case). -->
    <rule name="FormalParameterNamingConventions" ref="category/apex/codestyle.xml/FormalParameterNamingConventions">
        <priority>1</priority>
        <properties>
            <property name="finalMethodParameterPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="methodParameterPattern" value="[a-z][a-zA-Z0-9]*" />
        </properties>
    </rule>

    <!-- @name: LocalVariableNamingConventions
         @description: Configurable naming conventions for local variable declarations. 
         This rule reports variable declarations which do not match the regex that 
         applies to their specific kind (e.g. local variable, or final local variable). 
         Each regex can be configured through properties.

         By default this rule uses the standard Apex naming convention (Camel case). -->
    <rule name="LocalVariableNamingConventions" ref="category/apex/codestyle.xml/LocalVariableNamingConventions">
        <priority>1</priority>
        <properties>
            <property name="finalLocalPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="localPattern" value="[a-z][a-zA-Z0-9]*" />
        </properties>
    </rule>

    <!-- @name: MethodNamingConventions
         @description: Configurable naming conventions for method declarations. This 
         rule reports method declarations which do not match the regex that applies 
         to their specific kind (e.g. static method, or test method). Each regex can 
         be configured through properties.

         By default this rule uses the standard Apex naming convention (Camel case). -->
    <rule name="MethodNamingConventions" ref="category/apex/codestyle.xml/MethodNamingConventions">
        <priority>1</priority>
        <properties>
            <property name="testPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="staticPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="instancePattern" value="[a-z][a-zA-Z0-9]*" />
        </properties>
    </rule>

    <!-- @name: OneDeclarationPerLine
         @description: Apex allows the use of several variables declaration of the 
         same type on one line. However, it can lead to quite messy code. This rule 
         looks for several declarations on the same line. -->
    <rule name="OneDeclarationPerLine" ref="category/apex/codestyle.xml/OneDeclarationPerLine">
        <priority>1</priority>
        <properties>
            <property name="reportInForLoopInitializer" value="true" />
            <property name="strictMode" value="false" />
        </properties>
    </rule>

    <!-- @name: PropertyNamingConventions
         @description: Configurable naming conventions for property declarations. This 
         rule reports property declarations which do not match the regex that applies 
         to their specific kind (e.g. static property, or instance property). Each 
         regex can be configured through properties.

         By default this rule uses the standard Apex naming convention (Camel case). -->
    <rule name="PropertyNamingConventions" ref="category/apex/codestyle.xml/PropertyNamingConventions">
        <priority>1</priority>
        <properties>
            <property name="staticPattern" value="[a-z][a-zA-Z0-9]*" />
            <property name="instancePattern" value="[a-z][a-zA-Z0-9]*" />
        </properties>
    </rule>

    <!-- @name: IfStmtsMustUseBraces
         @description: Avoid using if statements without using braces to surround the 
         code block. If the code formatting or indentation is lost then it becomes 
         difficult to separate the code being controlled from the rest. -->
    <rule
        name="IfStmtsMustUseBraces"
        ref="category/apex/codestyle.xml/IfStmtsMustUseBraces"
        message="Avoid using if statements without curly braces"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: WhileLoopsMustUseBraces
         @description: Avoid using ‘while’ statements without using braces to surround 
         the code block. If the code formatting or indentation is lost then it becomes 
         difficult to separate the code being controlled from the rest. -->
    <rule
        name="WhileLoopsMustUseBraces"
        ref="category/apex/codestyle.xml/WhileLoopsMustUseBraces"
        message="Avoid using 'while' statements without curly braces"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: IfElseStmtsMustUseBraces
         @description: Avoid using if..else statements without using surrounding braces.
         If the code formatting or indentation is lost then it becomes difficult to 
         separate the code being controlled from the rest. -->
    <rule
        name="IfElseStmtsMustUseBraces"
        ref="category/apex/codestyle.xml/IfElseStmtsMustUseBraces"
        message="Avoid using 'if...else' statements without curly braces"
    >
        <priority>2</priority>
    </rule>

    <!-- @name: ForLoopsMustUseBraces
         @description: Avoid using ‘for’ statements without using surrounding braces. If 
         the code formatting or indentation is lost then it becomes difficult to separate 
         the code being controlled from the rest. -->
    <rule
        name="ForLoopsMustUseBraces"
        ref="category/apex/codestyle.xml/ForLoopsMustUseBraces"
        message="Avoid using 'for' statements without curly braces"
    >
        <priority>2</priority>
    </rule>
</ruleset>
